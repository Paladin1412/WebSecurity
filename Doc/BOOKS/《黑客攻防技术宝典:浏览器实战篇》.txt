第1章　浏览器安全概述1
1.1　首要问题1
1.2　揭密浏览器3
1.2.1　与Web应用休戚与共3
1.2.2　同源策略3
1.2.3　HTTP首部4
1.2.4　标记语言4
1.2.5　CSS5
1.2.6　脚本5
1.2.7　DOM5
1.2.8　渲染引擎5
1.2.9　Geolocation6
1.2.10　Web 存储7
1.2.11　跨域资源共享7
1.2.12　HTML58
1.2.13　隐患9
1.3　发展的压力9
1.3.1　HTTP首部9
1.3.2　反射型XSS过滤11
1.3.3　沙箱11
1.3.4　反网络钓鱼和反恶意软件12
1.3.5　混入内容12
1.4　核心安全问题12
1.4.1　攻击面13
1.4.2　放弃控制14
1.4.3　TCP协议控制15
1.4.4　加密通信15
1.4.5　同源策略15
1.4.6　谬论16
1.5　浏览器攻防方法16
1.5.1　初始化18
1.5.2　持久化18
1.5.3　攻击19
1.6　小结20
1.7　问题21
1.8　注释21
第2章　初始控制23
2.1　理解控制初始化23
2.2　实现初始控制24
2.2.1　使用XSS攻击24
2.2.2　使用有隐患的Web应用34
2.2.3　使用广告网络34
2.2.4　使用社会工程攻击35
2.2.5　使用中间人攻击45
2.3　小结55
2.4　问题55
2.5　注释56
第3章　持续控制58
3.1　理解控制持久化58
3.2　通信技术59
3.2.1　使用XMLHttpRequest轮询60
3.2.2　使用跨域资源共享63
3.2.3　使用WebSocket通信63
3.2.4　使用消息传递通信65
3.2.5　使用DNS隧道通信67
3.3　持久化技术73
3.3.1　使用内嵌框架73
3.3.2　使用浏览器事件75
3.3.3　使用底层弹出窗口78
3.3.4　使用浏览器中间人攻击80
3.4　躲避检测84
3.4.1　使用编码躲避85
3.4.2　使用模糊躲避89
3.5　小结96
3.6　问题97
3.7　注释98
第4章　绕过同源策略100
4.1　理解同源策略100
4.1.1　SOP与DOM101
4.1.2　SOP与CORS101
4.1.3　SOP与插件102
4.1.4　通过界面伪装理解SOP103
4.1.5　通过浏览器历史理解SOP103
4.2　绕过SOP技术103
4.2.1　在Java中绕过SOP103
4.2.2　在Adobe Reader中绕过SOP108
4.2.3　在Adobe Flash中绕过SOP109
4.2.4　在Silverlight中绕过SOP110
4.2.5　在IE中绕过SOP110
4.2.6　在Safari中绕过SOP110
4.2.7　在Firefox中绕过SOP112
4.2.8　在Opera中绕过SOP113
4.2.9　在云存储中绕过SOP115
4.2.10　在CORS中绕过SOP116
4.3　利用绕过SOP技术117
4.3.1　代理请求117
4.3.2　利用界面伪装攻击119
4.3.3　利用浏览器历史132
4.4　小结139
4.5　问题139
4.6　注释140
第5章　攻击用户143
5.1　内容劫持143
5.2　捕获用户输入146
5.2.1　使用焦点事件147
5.2.2　使用键盘事件148
5.2.3　使用鼠标和指针事件150
5.2.4　使用表单事件152
5.2.5　使用IFrame按键记录153
5.3　社会工程学154
5.3.1　使用标签绑架154
5.3.2　使用全屏155
5.3.3　UI期望滥用159
5.3.4　使用经过签名的Java小程序176
5.4　隐私攻击180
5.4.1　不基于cookie的会话追踪181
5.4.2　绕过匿名机制182
5.4.3　攻击密码管理器184
5.4.4　控制摄像头和麦克风186
5.5　小结192
5.6　问题192
5.7　注释193
第6章　攻击浏览器195
6.1　采集浏览器指纹196
6.1.1　使用HTTP首部197
6.1.2　使用DOM属性199
6.1.3　基于软件bug204
6.1.4　基于浏览器特有行为204
6.2　绕过cookie检测205
6.2.1　理解结构206
6.2.2　理解属性207
6.2.3　绕过路径属性的限制209
6.2.4　cookie存储区溢出211
6.2.5　使用cookie实现跟踪214
6.2.6　Sidejacking攻击214
6.3　绕过HTTPS215
6.3.1　把HTTPS降级为HTTP215
6.3.2　攻击证书218
6.3.3　攻击SSL/TLS层219
6.4　滥用URI模式220
6.4.1　滥用iOS220
6.4.2　滥用三星Galaxy222
6.5　攻击JavaScript223
6.5.1　攻击JavaScript加密223
6.5.2　JavaScript和堆利用225
6.6　使用Metasploit取得shell231
6.6.1　Metasploit起步231
6.6.2　选择利用232
6.6.3　仅执行一个利用233
6.6.4　使用Browser Autopwn236
6.6.5　结合使用BeEF和Metasploit237
6.7　小结240
6.8　问题240
6.9　注释240
第7章　攻击扩展244
7.1　理解扩展的结构244
7.1.1　扩展与插件的区别245
7.1.2　扩展与附加程序的区别245
7.1.3　利用特权245
7.1.4　理解Firefox扩展246
7.1.5　理解Chrome扩展251
7.1.6　IE扩展258
7.2　采集扩展指纹259
7.2.1　使用HTTP首部采集指纹259
7.2.2　使用DOM采集指纹260
7.2.3　使用清单文件采集指纹262
7.3　攻击扩展263
7.3.1　冒充扩展263
7.3.2　跨上下文脚本攻击265
7.3.3　执行操作系统命令277
7.3.4　操作系统命令注入280
7.4　小结284
7.5　问题284
7.6　注释285
第8章　攻击插件288
8.1　理解插件288
8.1.1　插件与扩展的区别289
8.1.2　插件与标准程序的区别290
8.1.3　调用插件290
8.1.4　插件是怎么被屏蔽的292
8.2　采集插件指纹292
8.2.1　检测插件293
8.2.2　自动检测插件295
8.2.3　用BeEF检测插件295
8.3　攻击插件297
8.3.1　绕过点击播放297
8.3.2　攻击Java302
8.3.3　攻击Flash311
8.3.4　攻击ActiveX控件314
8.3.5　攻击PDF阅读器318
8.3.6　攻击媒体插件319
8.4　小结323
8.5　问题324
8.6　注释324
第9章　攻击Web应用327
9.1　发送跨域请求327
9.1.1　枚举跨域异常327
9.1.2　前置请求330
9.1.3　含义330
9.2　跨域Web应用检测330
9.2.1　发现内网设备IP地址330
9.2.2　枚举内部域名331
9.3　跨域Web应用指纹采集333
9.4　跨域认证检测339
9.5　利用跨站点请求伪造342
9.5.1　理解跨站点请求伪造343
9.5.2　通过XSRF攻击密码重置345
9.5.3　使用CSRF token获得保护346
9.6　跨域资源检测347
9.7　跨域Web应用漏洞检测350
9.7.1　SQL注入漏洞350
9.7.2　检测XSS漏洞363
9.8　通过浏览器代理366
9.8.1　通过浏览器上网369
9.8.2　通过浏览器Burp373
9.8.3　通过浏览器Sqlmap375
9.8.4　通过Flash代理请求377
9.9　启动拒绝服务攻击382
9.9.1　Web应用的痛点382
9.9.2　使用多个勾连浏览器DDoS383
9.10　发动Web应用利用387
9.10.1　跨域DNS劫持387
9.10.2　JBoss JMX跨域远程命令执行388
9.10.3　GlassFish跨域远程命令执行390
9.10.4　m0n0wall跨域远程命令执行393
9.10.5　嵌入式设备跨域命令执行395
9.11　小结399
9.12　问题400
9.13　注释400
第10章　攻击网络404
10.1　识别目标404
10.1.1　识别勾连浏览器的内部IP404
10.1.2　识别勾连浏览器的子网409
10.2　ping sweep412
10.2.1　使用XMLHttpReqeust412
10.2.2　使用Java416
10.3　扫描端口419
10.3.1　绕过端口封禁420
10.3.2　使用IMG标签扫描端口424
10.3.3　分布式端口扫描426
10.4　采集非HTTP服务的指纹428
10.5　攻击非HTTP服务430
10.5.1　NAT Pinning430
10.5.2　实现协议间通信434
10.5.3　实现协议间利用446
10.6　使用BeEF Bind控制shell458
10.6.1　BeEF Bind Shellcode458
10.6.2　在利用中使用BeEF Bind463
10.6.3　把BeEF Bind作为Web shell472
10.7　小结475
10.8　问题475
10.9　注释476
第11章　结语：最后的思考479
