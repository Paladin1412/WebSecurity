第1章　 Web应用程序安全与风险
1.1　 Web应用程序的发展历程
1.1.1　 Web应用程序的常见功能
1.1.2　 Web应用程序的优点
1.2　 Web应用程序安全
1.2.1　 “本站点是安全的”
1.2.2　 核心安全问题：用户可提交任意输入
1.2.3　 关键问题因素
1.2.4　 新的安全边界
1.2.5　 Web应用程序安全的未来
1.3　 小结  第2章　 核心防御机制
2.1　 处理用户访问
2.1.1　 身份验证
2.1.2　 会话管理
2.1.3　 访问控制
2.2　 处理用户输入
2.2.1　 输入的多样性
2.2.2　 输入处理方法
2.2.3　 边界确认
2.2.4　 多步确认与规范化
2.3　 处理攻击者
2.3.1　 处理错误
2.3.2　 维护审计日志
2.3.3　 向管理员发出警报
2.3.4　 应对攻击
2.4　 管理应用程序
2.5　 小结
2.6　 问题
第3章　 Web应用程序技术
3.1　 HTTP
3.1.1　 HTTP请求
3.1.2　 HTTP响应
3.1.3　 HTTP方法
3.1.4　 URL
3.1.5　 REST
3.1.6　 HTTP消息头
3.1.7　 cookie
3.1.8　 状态码
3.1.9　 HTTPS
3.1.10　 HTTP代理
3.1.11　 HTTP身份验证
3.2　 Web功能
3.2.1　 服务器端功能
3.2.2　 客户端功能
3.2.3　 状态与会话
3.3　 编码方案
3.3.1　 URL编码
3.3.2　 Unicode编码
3.3.3　 HTML编码
3.3.4　 Base64编码
3.3.5　 十六进制编码
3.3.6　 远程和序列化框架
3.4　 下一步
3.5　 问题
第4章　 解析应用程序
4.1　 枚举内容与功能
4.1.1　 Web抓取
4.1.2　 用户指定的抓取
4.1.3　 发现隐藏的内容
4.1.4　 应用程序页面与功能路径
4.1.5　 发现隐藏的参数
4.2　 分析应用程序
4.2.1　 确定用户输入入口点
4.2.2　 确定服务器端技术
4.2.3　 确定服务器端功能
4.2.4　 解析受攻击面
4.2.5　 解析Extreme Internet Shopping应用程序
4.3　 小结
4.4　 问题  第5章　 避开客户端控件
5.1　 通过客户端传送数据
5.1.1　 隐藏表单字段
5.1.2　 HTTP cookie
5.1.3　 URL参数
5.1.4　 Referer消息头
5.1.5　 模糊数据
5.1.6　 ASP.NET ViewState
5.2　 收集用户数据：HTML表单
5.2.1　 长度限制
5.2.2　 基于脚本的确认
5.2.3　 禁用的元素
5.3　 收集用户数据：浏览器扩展
5.3.1　 常见的浏览器扩展技术
5.3.2　 攻击浏览器扩展的方法
5.3.3　 拦截浏览器扩展的流量
5.3.4　 反编译浏览器扩展
5.3.5　 附加调试器
5.3.6　 本地客户端组件
5.4　 安全处理客户端数据
5.4.1　 通过客户端传送数据
5.4.2　 确认客户端生成的数据
5.4.3　 日志与警报
5.5　 小结
5.6　 问题  第6章　 攻击验证机制
6.1　 验证技术
6.2　 验证机制设计缺陷
6.2.1　 密码保密性不强
6.2.2　 蛮力攻击登录
6.2.3　 详细的失败消息
6.2.4　 证书传输易受攻击
6.2.5　 密码修改功能
6.2.6　 忘记密码功能
6.2.7　 “记住我”功能
6.2.8　 用户伪装功能
6.2.9　 证书确认不完善
6.2.10　 非唯一性用户名
6.2.11　 可预测的用户名
6.2.12　 可预测的初始密码
6.2.13　 证书分配不安全
6.3　 验证机制执行缺陷
6.3.1　 故障开放登录机制
6.3.2　 多阶段登录机制中的缺陷
6.3.3　 不安全的证书存储
6.4　 保障验证机制的安全
6.4.1　 使用可靠的证书
6.4.2　 安全处理证书
6.4.3　 正确确认证书
6.4.4　 防止信息泄露
6.4.5　 防止蛮力攻击
6.4.6　 防止滥用密码修改功能
6.4.7　 防止滥用账户恢复功能
6.4.8　 日志、监控与通知
6.5　 小结
6.6　 问题
第7章　 攻击会话管理
7.1　 状态要求
7.2　 会话令牌生成过程中的薄弱环节
7.2.1　 令牌有一定含义
7.2.2　 令牌可预测
7.2.3　 加密令牌
7.3　 会话令牌处理中的薄弱环节
7.3.1　 在网络上泄露令牌
7.3.2　 在日志中泄露令牌
7.3.3　 令牌-会话映射易受攻击
7.3.4　 会话终止易受攻击
7.3.5　 客户端暴露在令牌劫持风险之中
7.3.6　 宽泛的cookie范围
7.4　 保障会话管理的安全
7.4.1　 生成强大的令牌
7.4.2　 在整个生命周期保障令牌的安全
7.4.3　 日志、监控与警报
7.5　 小结
7.6　 问题  第8章　 攻击访问控制
8.1　 常见漏洞
8.1.1　 完全不受保护的功能 
8.1.2　 基于标识符的功能
8.1.3　 多阶段功能
8.1.4　 静态文件
8.1.5　 平台配置错误
8.1.6　 访问控制方法不安全
8.2　 攻击访问控制
8.2.1　 使用不同用户账户进行测试
8.2.2　 测试多阶段过程
8.2.3　 通过有限访问权限进行测试
8.2.4　 测试“直接访问方法”
8.2.5　 测试对静态资源的控制
8.2.6　 测试对HTTP方法实施的限制
8.3　 保障访问控制的安全
8.4　 小结
8.5　 问题
第9章　 攻击数据存储区
9.1　 注入解释型语言
9.2　 注入SQL
9.2.1　 利用一个基本的漏洞
9.2.2　 注入不同的语句类型
9.2.3　 查明SQL注入漏洞
9.2.4　 “指纹”识别数据库
9.2.5　 UNION操作符
9.2.6　 提取有用的数据
9.2.7　 使用UNION提取数据
9.2.8　 避开过滤
9.2.9　 二阶SQL注入
9.2.10　 高级利用
9.2.11　 SQL注入之外：扩大数据库攻击范围
9.2.12　 使用SQL注入工具
9.2.13　 SQL语法与错误参考
9.2.14　 防止SQL注入
9.3　 注入NoSQL
9.4　 注入XPath
9.4.1　 破坏应用程序逻辑
9.4.2　 谨慎XPath注入
9.4.3　 盲目XPath注入
9.4.4　 查找XPath注入漏洞
9.4.5　 防止XPath注入
9.5　 注入LDAP
9.5.1　 利用LDAP注入
9.5.2　 查找LDAP注入漏洞
9.5.3　 防止LDAP注入
9.6　 小结
9.7　 问题  
第10章　 测试后端组件
10.1　 注入操作系统命令
10.1.1　 例1：通过Perl注入
10.1.2　 例2：通过ASP注入
10.1.3　 通过动态执行注入
10.1.4　 查找OS命令注入漏洞
10.1.5　 查找动态执行漏洞
10.1.6　 防止OS命令注入
10.1.7　 防止脚本注入漏洞
10.2　 操作文件路径
10.2.1　 路径遍历漏洞
10.2.2　 文件包含漏洞
10.3　 注入XML解释器
10.3.1　 注入XML外部实体
10.3.2　 注入SOAP
10.3.3　 查找并利用SOAP注入
10.3.4　 防止SOAP注入
10.4　 注入后端HTTP请求
10.4.1　 服务器端HTTP重定向
10.4.2　 HTTP参数注入
10.5　 注入电子邮件
10.5.1　 操纵电子邮件标头
10.5.2　 SMTP命令注入
10.5.3　 查找SMTP注入漏洞
10.5.4　 防止SMTP注入
10.6　 小结
10.7　 问题
第11章　 攻击应用程序逻辑
11.1　 逻辑缺陷的本质
11.2　 现实中的逻辑缺陷
11.2.1　 例1：征求提示
11.2.2　 例2：欺骗密码修改功能
11.2.3　 例3：直接结算
11.2.4　 例4：修改保险单
11.2.5　 例5：入侵银行
11.2.6　 例6：规避交易限制
11.2.7　 例7：获得大幅折扣
11.2.8　 例8：避免转义
11.2.9　 例9：避开输入确认
11.2.10　 例10：滥用搜索功能
11.2.11　 例11：利用调试消息
11.2.12　 例12：与登录机制竞赛
11.3　 避免逻辑缺陷
11.4　 小结
11.5　 问题
第12章　 攻击其他用户
12.1　 XSS的分类
12.1.1　 反射型XSS漏洞
12.1.2　 保存型XSS漏洞
12.1.3　 基于DOM的XSS漏洞
12.2　 进行中的XSS攻击
12.2.1　 真实XSS攻击
12.2.2　 XSS攻击有效载荷
12.2.3　 XSS攻击的传送机制
12.3　 查找并利用XSS漏洞
12.3.1　 查找并利用反射型XSS漏洞
12.3.2　 查找并利用保存型XSS漏洞
12.3.3　 查找并利用基于DOM的XSS漏洞
12.4　 防止XSS攻击
12.4.1　 防止反射型与保存型XSS漏洞
12.4.2　 防止基于DOM的XSS漏洞
12.5　 小结
12.6　 问题
