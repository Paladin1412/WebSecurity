
本文翻译自：https://www.wst.space/ssl-part1-ciphersuite-hashing-encryption/
https://www.wst.space/ssl-part-2-diffie-hellman-key-exchange/

SSL/TLS协议详解(上)：密码套件，哈希，加密，密钥交换算法

SSL的历史
  在了解SSL的历史时，有必要提一下Mozilla Foundation。说到Mozilla，首先我们想到的是他们著名的浏览器Firefox。根据各种消息来源来看，Firefox是继Chrome和Safari之后最受欢迎的浏览器。但Firefox杰出的前身是Netscape，在90年代它是互联网用户中最受欢迎的浏览器。尽管这样，在微软推出了Internet Explorer之后，Netscape的时代也就随之结束了，之后他们便建立了著名的Mozilla基金会，它仍然在成长。

  1994年，Netscape为Netscape Navigator浏览器研发了SSL。其作用主要是为了防止中间人攻击。后来，随着互联网可访问性的增加，银行开始利用互联网进行交易。当时安全性是一个很重要的问题，IETF （互联网工程任务组），也就是一群标准化互联网协议的人，他们研发属于自己的协议版本来标准化SSL，这是在1999年，现在该协议被称为TLS（传输层安全性），它的最新版本是TLS 1.3。
关于密码学的几点注意事项

  首先，在深入研究这个话题之前，我们需要对几件事情有一个基本的了解。最重要的一个是密码学。理解SSL您不需要成为密码学专家，但基本的了解是必要的。我们接下来会在这里讨论基础知识。已经知道非对称和对称密钥加密的朋友们可以直接跳过本节进入下一部分。

  密码学的处理对象是数字和字符串。基本上整个宇宙中的每一个数据都是数字。这里我们所说的数字，就是0和1，也就是二进制。你在屏幕上看到的图像，通过耳机听到的音乐，一切都是二进制文件，但我们的耳朵和眼睛都不能理解二进制文件吗？只有大脑才能理解这一点，但即使它能够理解二进制文件，它也无法享受二进制文件。因此，我们将二进制文件转换为人类可理解的格式，如mp3，jpg等。我们将这个过程称为编码，它是双向处理，可以很容易地解码成原始形式。
哈希

  散列是另一种数据一旦转换为其他形式将永远无法恢复的加密技术。在Layman的术语中，没有称为去散列的过程。有很多哈希函数都可以完成这项工作，比如sha-512，md5等等。wst.space 的sha-512 值是，

83d98e97ec1efc3cb4d20f81a246bff06a1c145b7c06c481defed6ef31ce6ad78db3ecb36e7ce097966f019eab7bdc7ffa6b
3f b8c5226871667ae13a6728c63b

您可以通过访问某个在线创建哈希网站并输入wst.space 来验证。

如果无法恢复原始值，那么我们在哪儿可以使用它呢？密码！当你给移动设备或PC设置密码时，便会创建哈希密码然后存储在安全的位置。当您下次进行登录尝试时，再次使用相同的算法（散列函数）对输入的字符串进行散列，并将输出与存储的值进行匹配。如果它是相同的，你就会登录。否则你将无法登录。

对密码运用哈希算法，我们就可以确保攻击者即使窃取了存储的密码文件也永远不会得到我们的密码。攻击者有的只是密码的哈希值。他也可能会找到最常用密码的列表，然后将sha-512应用于每个密码，再将其与手中的值进行比较，这种方法称为字典攻击。但这样做需要多久？如果您的密码足够随机，您认为这种破解方法是否有效？

我们在一篇博客文章中讨论了会话cookie。它的值是会话cookie，通常是哈希值。Facebook，Google和亚马逊数据库中的所有密码都经过哈希处理，或者至少它们应该被哈希化。
接下来是加密

  加密位于散列和编码之间。编码是一个双向过程，不应用于提供安全性。加密也是一个双向过程，但当且仅当加密密钥已知时才能检索原始数据。如果您不知道加密的工作原理，请不要担心，我们将在此讨论基础知识。这对理解SSL的基础知识已经足够了。共有两种类型的加密，即对称加密和非对称加密。
对称密钥加密

  我尽可能地说简单点。所以，我们可以通过移位算法来理解对称加密，这个算法是通过将字母向左或向右移动来加密字母表。我们取一个字符串CRYPTO并考虑一个数字+3，然后，CRYPTO的加密格式将是FUBSWR，也就是意味着每个字母向右移动3个位置。

  这里，单词CRYPTO称为明文，输出FUBSWR称为密文，值+3称为加密密钥（对称密钥），整个过程为密码。这是最古老和最基本的对称密钥加密算法之一，其首次使用是在Julius Caesar时期，所以以他的名字命名，它是一种著名的凯撒密码。任何知道加密密钥并且可以应用凯撒算法的人都可以反向并检索原始明文。因此，它被称为对称加密。
我们可以使用TLS进行对称加密吗

  如您所知，这种算法很容易破解，因为可能性较小。我们可以将key的值从1更改为任何内容，并逐个迭代26个字母。请注意，如果我们只加密小写英文字母，则key的值限制为26。我们的计算机使用Bruteforce处理这个过程只需几毫秒。如今，存在诸如AES（高级加密标准）和3DES（三重数据加密算法）的复杂算法。它们都被公认为很难破解。

  这是在发送和接收数据时在SSL/TLS中使用的加密技术。但客户端和服务器需要在开始加密数据之前就密钥达成一致并进行交换，是这样的吗？交换密钥的最初步骤显然是纯文本。如果攻击者在共享密钥时捕获密钥怎么办？那使用它也就没有了意义。因此，我们需要一种安全机制来交换密钥，而不会让攻击者真正看到它。所以就出现了非对称密钥加密的作用。
非对称密钥加密

  我们知道，在对称加密中，相同的密钥用于加密和解密。一旦该密钥被盗，所有数据都将消失。这是一个巨大的风险，我们需要更复杂的技术。1976年，Whitfield Diffie和Martin Hellman首次提出了非对称加密的概念，该算法被称为Diffie-Hellman密钥交换。然后在1978年，麻省理工学院的Ron Rivest，Adi Shamir和Leonard Adleman发表了RSA 算法。这些都可以被视为非对称加密的基础。

与对称加密相比，在非对称加密中，将有两个关键点而不是一个。一个称为公钥，另一个称为私钥。理论上，在启动期间，我们可以生成公私钥匙对我们的机器。私钥应保存在安全的地方，绝不应与任何人共享。顾名思义，公钥可以与希望向您发送加密文本的任何人共享。现在，那些拥有您的公钥的人可以使用它加密秘密数据。如果密钥对是使用RSA算法生成的，那么它们应该在加密数据时使用相同的算法。一般来说，加密算法会在公钥中指定，加密数据只能使用您拥有的私钥。
我们可以对所有TLS使用非对称加密吗

  非对称加密也称为公钥基础结构，又称PKI，这样命名的原因是自解释。不管怎样，只要您保持私钥安全，数据就是安全的。多好啊！所以，现在你可能会想，为什么我们仍然会在TLS中使用对称加密？我们有很多安全的PKI啊。是的，我也同意。但应该指出，必须在不影响可用性的情况下再处理安全的问题。由于PKI涉及双密钥架构并且密钥长度通常很大，因此加密-解密开销非常高。与对称密钥加密相比，它需要更多的时间和CPU占有率。

  因此，当在客户端和服务器之间发送和接收数据时，用户会感觉到等待的时间更久，而且浏览器会开始吃掉CPU。因此PKI仅用于在客户端和服务器之间交换对称密钥，此后，才是对称密钥加密开始起作用并且新的数据传输也使用了这种技术。好吧，我知道我只是在这里轻描淡写，因为我还没有真正涉足这个话题。请记住我们到目前为止所讨论的内容然后回到这儿，我们将从下一篇博客文章中深入探讨。
密钥交换算法

  在博客系列的最后部分，我们已经讨论了密码学的基本概念：包括散列，对称和非对称加密等。除了他们的历史，我没有说过任何关于SSL或TLS的内容。我希望我们已经完成了基础部分，所以让我们挖掘点真实的东西吧。在这篇博文中，我们将根据Diffie-Hellman密钥交换的密钥交换算法。
了解SSL中的加密类型

  从博客系列的最后一部分开始，我们知道在SSL中使用了对称加密和非对称加密，接下来，我们将看到使用了哪种加密算法，在哪里使用的以及使用的原因。

  想象一下，你正在浏览Facebook，Facebook在默认情况下通过https重新路由您的所有流量。由于您使用的是TLS（我将在大多数地方使用TLS而不是SSL，因为它现在是标准的）连接，您会在URL栏上看到一个绿色框以确认该连接是安全的。在单个会话期间，您会进行多项活动，例如评论，聊天，在页面之间导航，滚动新闻源等等。每次执行这些操作时，在客户端和服务器之间会共享多个请求和响应，所有这些通信都必须通过https才能确保数据安全。这意味着服务器和客户端浏览器正在为单个Facebook会话加密和解密数据包100次。

我们知道公钥加密的解密密钥永远不会与任何人共享，所以比对称密钥加密更安全，但是，如果我们还知道，在公钥基础设施（PKI）中，与对称密钥加密相比，它使用更多的CPU而且需要更多的时间来加密和解密，开销更高，导致浏览器（和应用程序服务器）开始占用您的CPU资源；此外，浏览器每次都必须经历繁忙的加密步骤，所以需要更多的时间才能提供内容。
如何解决

  鉴于以上原因，我们需要使用对称加密来实现这一目标，这样可以更快，资源消耗可以更少，两全其美。但客户端和服务器在开始加密之前必须就单个密钥达成一致，对吧？他们会怎么做？在共享唯一的密钥时，坐在客户端和服务器之间的攻击者可以捕获它和Kaboom！您的所有数据都泄漏了。故而必须有一种解决方法来共享密钥并在那里我们使用公钥加密。

  在客户端和服务器之间共享并同意一个秘密密钥的一系列过程我们称为握手，这是TLS的第一步。握手涉及多个过程，整个过程称为公钥基础结构，还记得我们在博客系列的最后部分使用了这个术语吗？PKI包括证书颁发机构（CA），数字签名等，我们将在下面深入讨论基础架构。
密钥交换算法

  因此，很明显非对称加密用于交换密钥，但用哪种算法呢？自从非对称密码学发明以来，提出了许多算法。在写这篇文章的过程中，TLS1.2是常用的标准，还有RSA、Diffie-Hellman密钥交换、ECDH（Elliptic Curve Diffie-Hellman）、SRP（安全远程密码）、由TLS 1.2支持密钥交换算法PSK（Pre Shared Key）。

在这里讨论所有算法可能是个麻烦事，相反我们将讨论最常见且易于理解的Diffie-Hellman密钥交换算法。
Diffie-Hellman Key Exchange解释

  我不打算直接去算，因为这方面并不是我的强项，而是让我们尝试用颜色类比来理解这个概念。想象一下，Alice和Bob正在做一些海报工作，他们的对手 Mallory也坐在替补席旁边。Alice和Bob想要达成共识，使用一种颜色来设计海报，他们无法大声讨论，因为Mallory会听到它。那么他们如何统一颜色呢？这个问题的解决方案就是Diffie-Hellman密钥交换算法的最简单形式，接下来我们来一探究竟。
方案步骤

    1.首先，Alice会选择一种常见的颜色，比如黄色，然后告诉Bob，她将在本次会议中使用黄色。显然，Mallory可以听到，但是没有关系。
    2.然后，Alice和Bob选择他们自己的秘密颜色，他们不会告诉对方。所以Mallory永远不会知道秘密颜色。例如，Alice选橙色作为秘密颜色，Bob选绿色。
    3.在这个步骤中，Alice将混合她的秘密颜色橙色和常用颜色黄色以产生新的颜色。凉鞋的颜色是可以吗？（我的颜色感觉不太好，原谅我。）
    4.同样，Bob也将他的秘密颜色与黄色混合以生成新的蓝色。
    5.Alice和Bob将告诉彼此这些新颜色。Mallory可以看到凉鞋颜色和蓝色，但不是他们的秘密颜色。
    6.交换完成后，Alice会将她的秘密颜色（橙色）混合到Bob发送的混合物中。Bob会将他的秘密颜色（绿色）与Alice发送的混合物混合。
    7.现在Alice和Bob都达到了一种共同秘密色彩的混合物。请参考下图。Mallory将会被凉鞋色和蓝色困住，因为Mallory不知道Alice和Bob的秘密颜色，所以他永远不会达到他们俩得到的共同的秘密颜色。

    这里，共同色（Yellow）可以被视为服务器的公钥，每个人都可以使用。最后获得的公共秘密可以被认为是用于在进一步的会话中加密数据的对称密钥，这不完全正确，但对于基本的理解，我们先保持这样，如果你深入挖掘，相信你会理解到精确的逻辑。

Diffie-hellman密钥交换视频链接
Diffie-Hellman密钥交换背后的数学

  让我们来看看上述算法背后的基本数学。为了更好地理解Diffie-Hellman的概念，我们需要了解模运算。那些不想看数学的朋友们可以跳过本节，其他人可以关注我。

很明显，当你将7和8加起来，你会得到15，这是小学算术问题。但是在12小时制的情况下，情况就不是这样的了。如果时间现在是7点，那么8小时后，时间将是3点。故而我们可以说时钟是算术模12的模运算的最简单的例子。在这种情况下，我们知道12:00也就相当于00:00，所以我们可以说12和0是一样的，反之亦然。

在数学上，
A = b(mod P)
如果我们将p的值设为12，将b设为21。然后，
21（mod 12）= 9

我们将其转换为Diffie-Hellman示例。在阅读以下内容时，请记住颜色类比。想象一下，Alice和Bob都知道g和p的值，或者Alice先前决定了这些值并将其发送给Bob。换句话说，这些值是公开的。现在，

观察到 S_A= S_B=K 。这是用于加密会话的会话密钥。
Mallory获得秘密钥匙的机会

  在整个过程中，请注意Alice（a）的秘密和Bob（b）的秘密永远不会彼此共享。因此，Mallory只知道g，p，A和B.为了得到K的值，Mallory首先需要从A = g^a（mod p）和B = g^b（mod p）计算a＆b ，数学上这被称为离散对数问题。对于较大的p值，要计算结果几乎100％不可行。在实际的TLS实现中，p的长度将在1024或2048位的范围内。也就是说，2048位密钥的长度在 2^2047和 2^2048之间。希望你知道一个2^3长度的秘钥的最大值可以为8.想象一下2048位密钥得有多复杂。

当使用这样的密钥时，即使是世界上最大的超级计算机也将花费100年的时间才能计算出a＆b。更不幸的是，这些值会随着每个会话而变化。所以啊，即使攻击者算出了这个值，在以下会话中他也无法用来模拟用户。这就是所谓的完美前瞻性保密。
我们现在安全吗

  服务器和客户端浏览器已经同意安全共享通过强密钥交换算法的密钥，一切都看起来很不错。但是先等等，我们真的足够安全吗？让我们想象一下我们尝试使用https连接到facebook.com的场景，假设攻击者已经位于您的浏览器和Facebook服务器之间，您的浏览器将告诉Facebook服务器启动TLS通道，但攻击者可以设置自己的服务器，并通过他的服务器重新路由你和Facebook.com之间的所有通信，因此，当Facebook服务器发送其公钥时，攻击者可以用他的公钥替换它并将其转发给您。

  然后下一步，您收到公钥认为它实际上来自Facebook.com，您的浏览器将使用它加密您的密钥并将其发送回Facebook。再一次，攻击者会抓住它并猜猜是什么？他有相应的私钥来解密密钥，然后用Facebook.com的公钥（他已经拥有）的原始值加密它并将其转发回Facebook.com，然后，他将继续进行加密 - 解密过程，如此一来，他就可以看到你和Facebook.com之间共享的所有内容。
现在怎么办

  问题的答案是CA（证书颁发机构）。简单来说，证书颁发机构由X.509标准指定，以确保数据的完整性，数据完整性可确保在传输中的数据不会被第三方实体篡改。换句话说，CA充当浏览器和服务器之间的中间人，确保数据完整性是CA的职责。

我们将在下一篇博客文章中深入讨论CA。

SSL/TLS协议详解(中)——证书颁发机构

上一篇中，我们讨论了关于Diffie Hellman算法的SSL/TLS密钥交换。我们最终认为需要第三方来验证服务器的真实性，并提出了证书颁发机构的机制。博客系列的最后两部分的主要内容：

        TLS加密客户端-服务器通信并阻止中间人攻击。
        编码，散列和加密之间的区别
        TLS使用对称密钥加密来加密数据和公钥基础结构以交换对称密钥。
        密钥交换算法本身可能被攻击者欺骗。因此，我们需要一个值得信赖的权威来验证服务器的真实性。

证书颁发机构的需求

  想象一下，客户端浏览器正在尝试与Web服务器通信，并且想要启动TLS通道。从上面的最后一点来看，为了证明服务器的身份，客户端浏览器必须具有服务器的公钥。但是，我们在浏览器中无法存储要访问的所有网站的公钥，而且由于每分钟都有新的网站出生，因此每分钟都需要更新一次。

  解决这个问题的方案是采用证书颁发机构机制。当我们安装浏览器或操作系统时，将会附有一组证书颁发机构，例如DigiCert。当浏览器自带DigiCert时，这意味着浏览器具有DigiCert的公钥，网站可以向DigiCert索取证书和签名。因此，DigiCert将使用DigiCerts私钥在服务器证书上进行加密签名。当我们发起连接时，服务器将发送嵌入了其公钥的证书。由于浏览器具有DigiCert的公钥，因此可以在服务器证书上验证DigiCert的签名，同时也说明证书上写的服务器的公钥是可信的。

如果您没有完全理解这个概念，也请不要担心。让我们把这个过程细化再逐一分析。
数字签名的定义

  要理解证书颁发机构的概念，我们可以回顾几十年前的传统邮箱邮件系统并进行类比。想象一下，Alice拥有一家公司，而Bob则是该公司的员工，Alice想给Bob发一封机密邮件，作为首席执行官的Alice，将起草邮件并将其放入邮箱，它将经过几个邮局和几个邮递员并最终到达Bob的手中，Bob可以打开阅读它，但Bob如何确保邮件真的来自Alice？这里有两种可能性：
1.攻击者Eve可以使用任何内容起草邮件，将发件人地址设置为类似于Alice的办公室的地址并将其转发给Bob。
2.Eve可以是中间人，例如中间邮局的员工，他可以在邮件到达Bob之前打开邮件，他甚至可以按照自己的意愿重写内容，然后将其重新发送给Bob。

在这两种情况下，都无法确保收到的Alice邮件是否有效。这种时候我们会做什么？查看签名，Alice可以在邮件发布给Bob时使用印章签名，Alice的公司印章可用于验证电子邮件的真实性和完整性。由于Alice的公司是公认的实体，如果邮件有签名，我们可以信任它，这正是证书颁发机构所做的事情。
证书颁发机构的技术实现

  我们知道PKI用于在TLS协议中交换会话密钥，此过程可以称为身份验证过程。为了执行认证过程，服务器需要向客户端发送公钥，但是中间攻击者可以获取此公钥并将其替换为自己的公钥，这是非常危险的，因为客户永远不会知道公钥在传输过程中是否被第三方篡改过。客户端会在不知不觉中使用攻击者的公钥加密对称密钥并转发出去，由于攻击者持有相应的私钥，他就可以解密并窃取数据。

为了使客户端信任所接收的公钥，引入CA的概念。 CA的工作如下。假设服务器https://example.com 需要TLS证书。
1.服务器 example.com将从CA请求TLS证书，例如Digicert。
2.Digicert将为example.com创建证书，证书将包含必要的数据，例如服务器名称，服务器的公钥等。
3.Digicert将创建数据（证书）的哈希值，并使用自己的私钥对其进行加密。
4.浏览器和操作系统自带Digicert等权威机构的公钥。
5.当浏览器收到签名证书时，它将使用公钥从签名生成哈希值，它还将使用证书中指定的散列算法生成数据（证书）的散列，如果两个哈希值匹配，则签名验证成功并且证书是可信的。
6.现在浏览器可以使用证书中指定的example.com的公钥继续进行身份验证过程。
在这里，我们可以将Digicert称为Root CA.
如果攻击者篡改证书会怎样

  收到证书后，浏览器将验证服务器名称、证书有效性、签名等数据。想象一下，如果攻击者使用他的自定义证书而不是example.com的证书，然后服务器名称字段验证将失败，浏览器将立即断开连接。

  另一种情况是，如果攻击者保留所有这些数据并用公钥替换公钥会发生什么？在这种情况下，当浏览器尝试从证书数据重新生成哈希时，由于数据被篡改，他将获得不同的哈希值，从而数据和签名计算出的哈希值将不匹配。

  为了绕过上述机制，攻击者需要使签名来匹配数据，为了做到这点，他需要拥有Digicert的私钥（最初为example.com签发并签署了证书），所以攻击者此时会失败，因为他可以创建的唯一签名来自他的私钥，我们的浏览器并不会信任这一点。浏览器的证书存储区也不会有攻击者的公钥，并且在发生此类攻击时会显示证书异常，如下所示。

  您可能已经注意到在尝试为浏览器设置代理时，发生私密错误是因为代理工具在充当中间人，并向浏览器显示自己的证书。如果您信任该证书，则可以点击继续；或者，您可以下载代理证书工具并将其添加到浏览器内的受信任机构列表中，这样，您可以在代理工具中以纯文本形式查看加密数据。
信任链

  我们知道证书颁发机构是为服务器创建并签署证书，很少有组织从事这项工作，即Digicert，Geotrust，Comodo等。如果他们正在为所有服务器签署证书，则必须为所有签名使用相同的私钥，如果它被盗，那么所有的信任都会丢失。为了解决这个问题并增加更多的平均信息量，引入了中间CA(intermediate CA)的概念。

  这个想法很简单。Charles是一个值得信赖的人，并曾经收到了Alice的签名邮件，如果Bob看到Charles的签名，他就会信任这封邮件。现在，Smith是Charles信任的另一个人，如果Smith代表Charles签署了一封来自Alice的邮件，那么Bob将不会一直相信它。这里就出现了信任链：Bob相信Charles和Charles信任Smith，因此BOb可以信任Smith。类似地，intermediate CA是Root CA信任的证书颁发机构。 example.com的证书将由intermediate CA颁发，intermediate CA还将具有将由Root CA签名的证书，并且只有Root CA的详细信息会被存储在浏览器的证书库中。

  因此，在证书验证期间，浏览器信任Digicert Root CA和Digicert Root CA信任intermediate CA，因此浏览器可以信任intermediate CA。在下图中，您可以看到层次结构，DigiCert SHA2 High Assurance Server CA是中间证书颁发机构和 DigiCert High Assurance EV Root CA。

此层次结构的另一个优点是Root CA无需始终在线。
数字签名的数学算法

  我们在理解密钥交换过程的同时讨论了Diffie-Hellman算法。类似地，也有许多算法可用于数字签名，这写会在服务器证书中指定。请参阅下面的example.com证书。

  我不会多谈核心的数学知识，因为它很无聊，而且我也很菜。证书显示带有RSA加密的SHA-256。 RSA是一种流行的签名算法，我会在这里讨论。与任何其他非对称加密算法一样，RSA也具有公钥 - 私钥对。这里的区别在于，签名（将其视为加密）是通过使用intermediate CA的私钥来完成的。并且签名验证（将其视为解密）由浏览器使用相应的公钥完成的。换句话说，RSA签名不是RSA解密。如果您有兴趣制作实用的RSA签名，请参阅此处。

  RSA将在签署之前会对证书进行哈希处理，这有一个很重要的原因。如果您深入了解算法，您将知道如果数据长度超过其密钥长度，RSA无法加密数据。假设我们使用2048位密钥进行加密，那么证书数据不应超过2048位，也就是255个字节，这并不总是可行的，因为证书包含很多信息。因此，在加密之前，在证书上应用散列函数，该函数生成指定长度的唯一随机字符串。在example.com的情况下，使用SHA-256哈希算法。如果您有兴趣，可以进一步研究RSA的这种限制。
浏览器如何实际验证给定服务器证书的有效性

  我们知道服务器使用中级证书颁发机构的签名，因此，在与浏览器通信时，服务器将共享两个证书：一，包含服务器的公钥，即实际的服务器证书；二，由Root CA颁发的intermediate CA证书。以下是验证链的图示。

  在签名验证期间，浏览器首先使用已经存储在浏览器中的Root CA的公钥来验证中间证书的数字签名，如果成功，浏览器现在可以信任中间证书及其公钥。现在使用此公钥，浏览器将验证原始服务器证书的签名，该组织可以注册为intermediate CA，以便为其域签署证书。比如谷歌。

  谷歌互联网管理局G3是一个由全球认证Root CA -R2信任的intermediate CA，这意味着，Google可以使用此intermediate CA验证其域名，由于谷歌浏览器是全球认证Root CA认证的，其他浏览器将信任它。必须注意的是，谷歌有权单独签署他们的域名。这可以防止Google为Microsoft签署证书。
后续

到目前为止，我们已经讨论了证书颁发机构和TLS协议的原理。在本系列的下一部分中，我们将实际检查整个TLS通信。

SSL/TLS协议详解(下)——TLS握手协议

本文翻译自：https://www.wst.space/ssl-part-4-tls-handshake-protocol/

  在博客系列的第2部分中,对证书颁发机构进行了深入的讨论.在这篇文章中，将会探索整个SSL/TLS握手过程，在此之前，先简述下最后这块内容的关键要点：

        TLS适用于对称密钥
        对称密钥可以通过安全密钥交换算法共享
        如果请求被截获，密钥交换可能会被欺骗
        使用数字签名进行身份验证
        证书颁发机构和信任链。

  在这篇文章中，使用WireShark的工具来查看网络流量，我个人使用的是Linux（Ubuntu 16.04）系统，可以使用以下命令轻松安装WireShark：

$sudo apt install wireshark

  以sudo的权限打开WireShark并选择提供互联网连接的接口，我这里是eth0，然后点击WireShark右上角的“开始捕获数据包”按钮，Wireshark将立即开始抓取通过机器的所有流量。现在我们从浏览器中加载github.com。Github使用TLS进行所有通信，将重新定向到https并加载。现在关闭浏览器，看看WireShark抓到了什么。
DNS解析

  这并不是TLS的一部分，但我们在WireShark中看到了它。

  我已将Google DNS设置为我的DNS服务器，它的地址是8.8.8.8，在图像中可以看到请求已发送到8.8.8.8查询github.com的A记录，也就是我们想要连接的Github的IP地址。

  DNS服务器使用github.com的IP响应为192.30.253.113，蓝色表示选择显示相应的部分，现在，浏览器已获取了将要用来连接服务器的目标IP。
发起TLS握手

  解析IP后，浏览器将通过http请求页面，如果服务器支持TLS，那么它将发送协议升级请求来响应浏览器，这个新的地址https://github.com ,将使用端口号443来指定，随后浏览器将启动TLS握手请求。大多数现代浏览器都存有与Web服务器的最后一次连接的记录，如果最后一次连接是通过https进行的，那么下次浏览器将自动启动https请求而无需等待服务器。
TLS握手分为以下几个步骤：

        客户端发送Hello报文
        服务器接收Hello报文
        共享证书和服务器密钥交换
        更改密码规范
        加密握手

客户端发送Hello报文

  从这里开始，我将会重点讨论图片中标记为蓝色的主题，Client发送的Hello报文如下图所示。

  我们知道TLS是在TCP之上实现的协议，TLS本身是一层协议并且它的底层叫做记录协议(Record protocol)，这意味着所有数据都被记录。典型的记录格式如下：

HH V1:V2 L1:L2 data

        HH是单个字节，表示记录中的数据类型。共定义了四种类型：change_cipher_spec（20），alert（21），handshake（22）和application_data（23）。
        V1：V2是协议版本，用两个以上的字节表示。对于当前定义的所有版本，V1的值为0x03，而对于SSLv3，V2的值为0x00，对于TLS 1.0为0x01，对于TLS 1.1为0x02，对于TLS 1.2为0x03。
        L1：L2是数据的长度，以字节为单位（使用big-endian约定：长度为256 * L1 + L2），数据的总长度不能超过18432字节，但实际上它无法达到这个值。

  在图中，可以看出内容类型是Handshake，TLS版本1.0，数据长度为512.真实数据位于名为 Handshake Protocol：Client Hello的下拉列表中。我们继续观察下Client Hello中共享的数据。
客户端发送Hello报文的内容

  浏览器与服务器共享以下详细信息
客户端版本

  按优先顺序列出的客户端支持的协议版本，首选客户希望支持的最新协议版本。
客户端的随机数

  一个32字节的数据，其中前4个字节表示epoch格式的当前日期时间。纪元时间是自1970年1月1日以来的秒数。其余28个字节由加密强随机数生成器生成（例如，Linux中的/dev/urandom），客户端随机会在后面用到，请先记住这点。
会话id(Session id)

  如果客户端第一次连接到服务器，那么这个字段就会保持为空。在上图中，您可以看到Session id正在给服务器发送东西，之所以会发生这种情况是由于我之前是通过https连接到github.com的，在此期间，服务器将使用Session id映射对称密钥，并将Session id存储在客户端浏览器中，为映射设置一个时间限。如果浏览器将来连接到同一台服务器（当然要在时间限到期之前），它将发送Session id，服务器将对映射的Session进行验证，并使用以前用过的对称密钥来恢复Session，这种情况下，就不需要完全握手。
密码套件

  客户端还将发送自己已经知道的密码套件列表，这个是由客户按优先顺序排列的，但完全由服务器来决定发送与否。TLS中使用的密码套件有一种标准格式。

我们从列表中用一个例子来进行分析.

Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)

        TLS：指使用的协议是TLS
        ECDHE：密钥交换算法
        ECDSA：签名或验证算法
        AES_128_GCM：称为批量加密算法。对称密钥加密算法是AES，密钥长度为128位，AES是块密码，也就是对输入的纯文本用固定长度的块来进行加密，加密后的每个块按再顺序发送，最后按类似的方式来进行解密。按标准规定，AES块固定长度为128位，但是输入的明文不要求必须是128的倍数，所以我们可能需要对最后一个块中进行填充，使其为固定的长度128位。除此之外，为了提高平均信息量，通常在加密之前会添加一些随机的比特到明文中，我们称为初始化矢量（IV）。有很多算法都可以在块上添加IV实现填充。在我们的例子Galois/Counter Mode(GCM)中用到过。或许详细解释GCM模式会使事情变得复杂，可见这并不是一个好主意。
        SHA256：消息验证代码（MAC）算法。我们将详细讨论MAC。

压缩数据

  为了减少带宽，可以进行压缩。但从成功攻击TLS的事例中来看，其中使用压缩时的攻击可以捕获到用HTTP头发送的参数，这个攻击可以劫持Cookie，这个漏洞我们称为CRIME。从TLS 1.3开始，协议就禁用了TLS压缩。
扩展名

  其他参数（如服务器名称，填充，支持的签名算法等）可以作为扩展名使用，我们可以任意对用作扩展名的内容研究一番。

  这些是客户端问候的一部分，如果已收到客户端问候，接下来就是服务器的确认，服务器将发送服务器问候。
服务器接收Hello报文

  收到客户端问候之后服务器必须发送服务器问候信息，服务器会检查指定诸如TLS版本和算法的客户端问候的条件，如果服务器接受并支持所有条件，它将发送其证书以及其他详细信息，否则，服务器将发送握手失败消息。

图中，我们可以看到服务器响应0x0303表示服务器同意使用TLS 1.2，我们来检查一下服务器问候中的记录。
服务器接收Hello报文的内容

  服务器问候消息包含以下信息。

加下来我们会在这里讨论其中一些重要的参数。
服务器版本

  如果客户端可以支持，则服务器将选择客户端指定的TLS版本，这里选择了TLS 1.2
服务器的随机数

  类似于客户端随机，服务器随机也占32字节，前4个字节表示服务器的Unix纪元时间，后面加上28字节的随机数。客户端和服务器随机将用来创建加密密钥，我待会儿会解释。
密码套件

  还记得我们已经将发送支持的密码套件发送到客户端问候中的github.com吗？Github从名单中选出了第一个，也就是：

TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256

会话id(Session id)

  服务器将约定的Session参数存储在TLS缓存中，并生成与其对应的Session id。它与Server Hello一起发送到客户端。客户端可以写入约定的参数到此Session id，并给定到期时间。客户端将在Client Hello中包含此id。如果客户端在此到期时间之前再次连接到服务器，则服务器可以检查与Session id对应的缓存参数，并重用它们而无需完全握手。这非常有用，因为服务器和客户端都可以节省大量的计算成本。

  在涉及亚马逊和谷歌等流量巨大的应用程序时，这种方法存在缺点。每天都有数百万人连接到服务器，服务器必须使用Session密钥保留所有Session参数的TLS缓存。这是一个巨大的开销。为了解决之前介绍过的Session Tickets的问题, 在这里，客户端可以在client hello中指定它是否支持Session Ticket。然后，服务器将创建一个新的会话票证(Session Ticket)，并使用只有服务器知道的经过私钥加密的Session参数。它将存储在客户端上，因此所有Session数据仅存储在客户端计算机上，但Ticket仍然是安全的，因为该密钥只有服务器知道。

  此数据可以作为名为Session Ticket的扩展包含在Client Hello中。在我们的例子中，此参数为空，因为这是第一次连接到github.com或前一个Session的浏览器已过期。

压缩数据

  如果支持，服务器将同意客户端的首选压缩方法。在这里，您可以看到服务器响应为空响应，则意味着不需要压缩。

  服务器不在ServerHello消息中发送任何证书; 它会在正确命名的证书消息中发送证书。
服务器证书的信息


  在我们的例子中，证书消息长度为3080字节。毫无疑问，这是包含所有信息的服务器证书。服务器按信任链的顺序发送完整的证书列表。该链中的第一个是服务器证书，接着是颁发服务器证书的intermediate CA 的证书,然后是下一个intermediate CA 的证书......直到Root CA的证书。服务器不可以发送Root CA证书，因为在大多数情况下，浏览器可以从任何intermediate CA 识别Root CA。

  在我们的例子中，您可以看到第一个证书是github.com，第二个证书是中间件Digicert SHA2扩展验证Server CA。 检查下图中的id-at-commonName参数。

让我们分析证书的内容，看看浏览器如何验证它。
证书的内容

  证书被发送到浏览器，因此我们可以在访问github.com时查看Github的证书。来自Firefox的CA证书内容:

可以通过单击"详细信息"选项卡查看github的intermediate CA 和Root CA.

让我们了解这些领域是什么以及它们的用途。
版本和序列号

  版本表示使用的是哪个版本的X.509标准。X.509是用于定义公钥证书格式的标准。X.509有3个版本，github使用最新版本version 3。

  从RFC 5280开始，CA为每个证书分配的序列号必须是正整数。因此对于每个发布CA证书，它必须是唯一的（即颁发者名称和序列号标识唯一的证书）。所以，CA必须强制serialNumber为非负整数。
证书的签名算法与值

  浏览器需要知道签名算法以验证签名。如果使用的是RSA签名，则需要相同的算法来验证签名。对于Github，使用的是PKCS＃1 SHA-256和RSA加密，即SHA-256用于生成散列，RSA用于签名。

  从我们上一篇文章中，证书数据使用SHA-256算法进行哈希处理，并使用RSA加密过Github的私钥对此哈希进行签名。
颁布机构

  此字段包含颁发证书的颁发机构的详细信息。Github的证书由Digicert的intermediate CA 颁发。

合法性

  该字段有两个值Not Before 和Not After 。如果当前日期时间不在这些值之间，则证书无效。浏览器就不会信任该证书。
子公钥信息(Subject Public Key Info)

  该字段携带公钥和用于生成公钥的算法。此密钥用于交换密钥，我们将在稍后讨论。
指纹

  浏览器生成了两个指纹SHA 1和SHA-256，而且不会发送到服务器。这些指纹分别是通过SHA 1和SHA-256函数散列DER格式的证书产生的。我们可以通过将证书下载到我们的机器并应用哈希函数来验证这一点。

  单击详细信息选项卡左下角的“ 导出” 按钮以下载证书，保存为.crt 扩展名，并在终端上运行以下命令以生成证书的指纹。

$ openssl x509 -noout -fingerprint -sha256 -inform pem -in [certificate-file.crt]

$ openssl x509 -noout -fingerprint -sha1 -inform pem -in [certificate-file.crt]

  这应该产生与您在浏览器中看到的结果相同的结果。这些值不是证书的一部分，而是根据证书计算出来的。Root CA证书的指纹将在浏览器中进行硬编码，因此可以轻松地进行交叉验证。除此之外，这些指纹主要用于识别和组织证书。不要将Signature与指纹混淆。

  我们在这里讨论的证书信息是关于github.com的服务器证书。Github的intermediate CA 证书也将在同一请求中发送给客户，所有上述字段也适用于该证书。您可以通过转到详细信息选项卡并单击intermediate CA 来检查，如下所示。

服务器端密钥交换

  随后是Server Hello和证书消息(Certificate message)，服务器密钥交换(Server Key Exchange)是可选的。仅当服务器提供的证书不足以允许客户端交换预主密钥时，才会发送此消息。让我们看看为什么github.com必须发送服务器密钥交换消息。

  我们可以看到github.com首选Session的密码套件是TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256。这意味着双方使用Elliptic Curve Diffie Hellman算法来交换密钥。在Diffie-Hellman中，客户端无法自行计算预主密钥; 双方都有助于计算它，因此客户端需要从服务器获取Diffie-Hellman公钥。（不要对"Pre-Master Secret"一词感到困惑，我们将在下面深入讨论它。）当使用Elliptic Curve Diffie-Hellman时，该公钥不在证书中。因此，服务器必须在单独的消息中向客户端发送其DH公钥，以便客户端可以计算预主密钥。这可以在上面的图像中看到。请注意，此密钥交换也由签名保护。

  服务器密钥交换完成后，服务器将发送Server Hello Done 消息。客户端将开始计算Pre-Master Secret。我们来看看如何。
如何计算Pre-Master Secret

  Pre-Master Secret计算取决于商定的密钥交换算法的类型。当使用RSA进行密钥交换时，从客户端（即浏览器）计算预主密钥，客户端通过连接协议版本（2个字节）和客户端随机生成的一些字节（46个字节）来生成48字节的预主密钥。客户端从加密安全的伪随机数发生器（PRNG）获得这46个字节。实际上，这意味着使用操作系统提供的PRNG，例如/dev/urandom。然后，使用服务器的公共和共享对此Pre-Master密钥进行加密，以便服务器稍后可以使用它来创建主密钥。

  但是，在Github的情况下，如上所述，Diffie-Hellman算法用于密钥交换。这里的情况略有不同。服务器立即生成一对DH私钥 - 公钥。然后，与客户共享公钥。这是如上所述的"服务器密钥交换消息( Server Key Exchange)"。作为响应，客户端还将创建DH密钥对，并通过客户端密钥交换消息与服务器共享公钥，如下所示。

  您可以看到共享的客户端公钥。现在，如果您了解Diffie-Hellman算法的工作原理，您就知道客户端和服务器可以从这些共享公钥到达公共密钥。新生成的密钥称为Pre-Master密钥。

  使用Diffie Hellman算法进行TLS密钥交换具有优势。客户端和服务器都为每个新会话生成一个新密钥对。一旦计算出预主密钥，将立即删除客户端和服务器的私钥。这意味着私钥永远不会被窃取，确保完美的前向保密。
客户端密钥交换

  我们已经在上面讨论过，客户端的DH公钥通过客户端密钥交换消息共享给服务器。但是如果使用RSA，则客户端将如上所述通过其自己计算预主密钥，使用服务器的公钥（RSA公钥）对其进行加密，并通过客户端密钥交换消息将其发送回服务器。然后，服务器可以使用其私钥解密它。无论算法是什么，此时客户端和服务器都达到了共同的Pre-Master Secert 。完成此操作后，客户端将发送Change Cipher Spec 消息，如下所示。

让我们往下走，看看如何在主密钥从预备主密钥来计算。
如何计算主秘钥

  现在客户端和服务器都有哪些随机数据呢？根据RFC 5346标准，在问候消息期间客户端和服务器共享的预主密钥和随机值（还记得吗？）都会使用PRF（伪随机函数）产生的值来计算主密钥。

master_secret = PRF（pre_master_secret，“master secret”，ClientHello.random + ServerHello.random）[0..47];

这里，

pre_master_secret - 双方计算的48字节Pre-Master密码。

“master secret” - 它只是一个使用ASCII字节的字符串。

ClientHello.random - 客户端hello中共享的随机值

ServerHello.random - 服务器hello中共享的随机值。

  主密钥的大小共48个字节，好吧，到目前为止还不是太乱。双方都可以使用主密钥加密数据并来回发送，确实如此，但程序还没结束。你认为双方使用相同的秘钥是个好办法吗？当然不是！TLS为客户端和服务器分配了单独的密钥，它们都来自主密钥本身，换句话说，主密钥不直接用于加密数据，而是将单独的加密密钥用于客户端和服务器。由于双方都有两个密钥，服务器用其密钥加密的数据可以由客户端轻松解密，反之亦然。

  还没完，TLS还具有用于对称密钥加密的附加安全机制。
消息验证代码（MAC）和TLS数据完整性

  窃听者可以对传输中的加密数据进行两种可能的攻击：尝试解密数据或尝试修改数据。只要密钥安全，我们就可以认为解密基本上是不可能的，但如果是修改数据呢？客户端和服务器是怎么知道攻击者没有修改过数据呢？如上所述，TLS不仅仅是加密数据，还可以保护数据，使其免受未检测到的修改，换句话说，TLS可以检查数据的完整性。让我们看看它是怎么做到的。

  当服务器或客户端使用主密钥加密数据时，它还会计算明文数据的校验和（哈希值），这个校验和称为消息验证代码（MAC）。然后在发送之前将MAC包含在加密数据中。密钥用于从数据中生成MAC，以确保传输过程中攻击者无法从数据中生成相同的MAC，故而MAC被称为HMAC（哈希消息认证码）。另一方面，在接收到消息时，解密器将MAC与明文分开，然后用它的密钥计算明文的校验和，并将其与接收到的MAC进行比较，如果匹配，那我们就可以得出结论：数据在传输过程中没有被篡改。

  客户端和服务器必须使用相同的散列算法来创建以及验证MAC，还记得Github同意的密码套件的最后一部分吗？
TLS_ECDHE_ECDSA_WITH_AES_128_GCM_ SHA256。即SHA256 是用于处理HMAC的哈希函数，为了提高安全性，客户端和服务器使用MAC密钥。让我们看看这些是什么。
MAC密钥和IV密钥

  根据要求，有4个密钥用于加密和验证每个消息的完整性，他们是：

        客户端写入加密密钥：客户端用赖加密数据，服务器用来解密数据。
        服务器写入加密密钥：服务器用来加密数据，客户端用来解密数据。
        客户端写入MAC密钥：客户端用来创建MAC，服务器用来验证MAC。
        服务器写入MAC密钥：服务器用来创建MAC，客户端用来验证MAC。

  这些密钥块由主密钥上的相同的PRF反复地生成，直至密钥有了足够的字节。

key_block = PRF（SecurityParameters.master_secret，“密钥扩展”，SecurityParameters.server_random + SecurityParameters.client_random）;

  如您所见，除了客户端 - 服务器随机值和字符串“密钥扩展”之外，主密钥还用来增加密钥的平均信息量。PRF可以生成任意长度的密钥，这点是很有用的，因为默认情况下不同的散列函数具有不同的长度。在我们的例子中用的是SHA256，它是256位，但MD5的默认长度为128位。

  除此之外，我们知道我们使用的AES和GCM算法是一种分组密码，它需要一组比特来作为初始化向量（IV）。在讨论密码套件时，我们已经提到IV用于改善AES加密的平均信息量，换句话说，当多次加密同一文件时，IV能够生成不同的密文，这些随机的字节也由相同的PRF生成，并且被称为客户端写入IV 和服务器写入IV ，术语是自解释的。我不会对IV的细节再进行更多讲解，因为它是一个很大的主题，超出了本文的范围。
生成测试数据

  现在双方都有了加密密钥，我们准备加密，但是在将TLS放到应用层之前，我们需要像每个进程一样来测试并验证客户端加密数据是否可以由服务器解密，反之亦然。为此，客户端将使用伪随机函数（PRF）计算12字节的verify_data，如下所示。

verify_data = PRF(master_secret, "client finished", MD5(handshake_messages) + SHA-1(handshake_messages) ) [12]

  其中handshake_messages 是所有握手消息的缓冲区，以上版本适用于版本1.2的TLS。版本1.2略有变化，即verify_data的长度取决于密码套件而不总是12字节，任何未明确指定verify_data_length的密码套件都等于12。此外，伪随机函数（PRF）中的MD5 / SHA-1组合具有已被密码套件指定的PRF替换。所以根据最新规范，

Verify_data = PRF(master_secret, finished_label, Hash(handshake_messages)) [0..verify_data_length-1];

  因此我们有测试数据，用密钥和算法来加密测试数据。客户端所需要做的就是用客户端加密密钥（或简称客户端写入密钥）使用AES算法加密测试数据，如上所述还得计算HMAC，客户端获取结果并添加记录头字节“0x14”表明“已完成”，再通过客户端生成消息并且发送到服务器。这是由实体和客户端发送的最后一次握手消息之间协商的算法和密钥保护的第一条消息。由于消息是完全加密的，因此WireShark只会看到加密的内容，并通过名称为加密握手的消息来调用完成的握手信息，如下所示。

验证磋商

  服务器处理过程也几乎相同。它发出一个Change Cipher Spec ，然后发送一条包含所有握手消息的已完成信息。更改标记在该服务器切换到新协商的加密套件和键点的密码SPEC消息，然后再加密后续客户端的记录。除此之外，服务器的完成消息将包含对客户端的完成消息进行解密的版本，一旦客户端收到此数据，它将使用服务器写入密钥对其进行解密。故而这就向客户证明了服务器能够成功解密我们的消息。KABOOM！我们完成了TLS握手。

  所有的加密都是基于协商的算法。在我们的例子中，算法是AES_128_GCM，这里没有必要进行进一步的解释，因为当涉及到其他网站时，服务器指定的算法可能会有所不同。如果您有兴趣了解这些算法的工作原理，维基百科有一个列表。我也是通过TLS基础知识来学习密码学。
加密应用程序数据

  我们现在在应用层。如果你有一个中等速度的互联网连接，我们只是连接了几百毫秒。想象一下，在如此短的时间内会发生多少事情？

我要求的页面是homepade aka www.github.com

。所以在Mozilla Firefox的开发者工具中显示的纯文本请求是，

GET https://github.com/

Host: github.com

User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:61.0) Gecko/20100101 Firefox/61.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept-Language: en-US,en;q=0.5

Accept-Encoding: gzip, deflate, br

Connection: keep-alive

Upgrade-Insecure-Requests: 1

Cache-Control: max-age=0

请参阅下图：

前3个字节17 03 03 表示内容的数据类型（应用程序数据）和TLS版本（TLS 1.2）。
尾声

对，就是这样。我们结束了。
